#!/usr/bin/env python
'''\
This script converts an FSM-SADF model generated by the SDF3 tool to an SADF ForSyDe model.
The script takes as input the path to the SADF model and the path to the output file.

Usage: sdf3-sadf-to-forsyde.py <input_file_path> <output_file_path>
'''

import sys
import os
import xml.etree.ElementTree as ET
import xml.dom.minidom as minidom

'''\
Extract the scenario table from the generated SADF model.
The functions gets the actor name and the applicationGraph XML element as input and returns
the scenario table as a dictionary with the scenario as they key and a tuple of lists of
input and output consumption rates as the value. 
'''
def extract_scenario_table(actor_name, inproot):
    scenarios = inproot.find('fsmsadfProperties/scenarios')
    actor_graph = inproot.find('fsmsadf/scenariograph/actor/[@name="{}"]'.format(actor_name))
    scenario_table = {}
    for scenario in scenarios.findall('scenario'):
        scenario_table[scenario.attrib['name']] = ([], [])
        for inpport in scenario.findall('actorProperties/[@actor="{}"]/port'.format(actor_name)):
            if actor_graph.find('port/[@name="{}"]/[@type="in"]'.format(inpport.attrib['name'])) is not None:
                scenario_table[scenario.attrib['name']][0].append(inpport.attrib['rate'])
            else:
                scenario_table[scenario.attrib['name']][1].append(inpport.attrib['rate'])
    return scenario_table

'''\
Convert the SDF3-based SADF model to a ForSyDe-based SADF model.
The function gets the root XML element of the SDF3-generated FSM-SADF model as input and
returns the root XML element of the ForSyDe-based SADF model.
'''
def sdf3_to_forsyde(inproot):
    inproot_sadf = inproot.find('applicationGraph/fsmsadf/scenariograph')

    # # Create the XML document
    # doc = minidom.Document()

    # Create the root element
    outroot = ET.Element('process-network')
    outroot.set('name', os.path.splitext(os.path.basename(sys.argv[2]))[0])

    # Generate signals
    for inpchannel in inproot_sadf.findall('channel'):
        channel_attribs = inpchannel.attrib
        outsignal = ET.SubElement(outroot, 'signal')
        outsignal.set('name', channel_attribs['name'])
        outsignal.set('moc', 'sadf')
        outsignal.set('type', 'double')
        outsignal.set('source', channel_attribs['srcActor'])
        outsignal.set('source_port', channel_attribs['srcPort'])
        outsignal.set('target', channel_attribs['dstActor'])
        outsignal.set('target_port', channel_attribs['dstPort'])
    
    # Generate delay actors
    for inpchannel in inproot_sadf.findall('channel'):
        channel_attribs = inpchannel.attrib
        if 'initialTokens' in channel_attribs and channel_attribs['initialTokens'] > '0':
            # make a delayn
            outprocess = ET.SubElement(outroot, 'leaf_process')
            outprocess.set('name', channel_attribs['name'] + '_delay')
            ET.SubElement(outprocess, 'port', {'name': "iport1", 'moc': "sadf", 'type': "double", 'direction': "in"})
            ET.SubElement(outprocess, 'port', {'name': "oport1", 'moc': "sadf", 'type': "double", 'direction': "out"})
            outpc = ET.SubElement(outprocess, 'process_constructor', {'name': "delayn", 'moc': "sadf"})
            ET.SubElement(outpc, 'argument', {'name': "init_val", 'value': "0.0"})
            ET.SubElement(outpc, 'argument', {'name': "n", 'value': channel_attribs['initialTokens']})

            # make a new signal
            outsignal = outroot.find("signal/[@name='{}']".format(channel_attribs['name']))
            newoutsig = ET.Element('signal')
            newoutsig.set('name', channel_attribs['name'] + '_delaysig')
            newoutsig.set('moc', 'sadf')
            newoutsig.set('type', 'double')
            newoutsig.set('source', channel_attribs['name'] + '_delay')
            newoutsig.set('source_port', 'oport1')
            newoutsig.set('target', outsignal.attrib['target'])
            newoutsig.set('target_port', outsignal.attrib['target_port'])
            outroot.insert(list(outroot).index(outroot.find('leaf_process')), newoutsig)

            # rewire the original signal
            outsignal.set('target', channel_attribs['name'] + '_delay')
            outsignal.set('target_port', 'iport1')
    
    # Generate the kernel processes
    for inpactor in inproot_sadf.findall('actor'):
        actor_attribs = inpactor.attrib
        outprocess = ET.SubElement(outroot, 'leaf_process')
        outprocess.set('name', actor_attribs['name'])
        for inpport in inpactor.findall('port'):
            port_attribs = inpport.attrib
            ET.SubElement(outprocess, 'port', {'name': port_attribs['name'], 'moc': 'sadf', 'type': 'double', 'direction': port_attribs['type']})
        outpc = ET.SubElement(outprocess, 'process_constructor')
        outpcnuminps = len(inpactor.findall('port/[@type="in"]'))
        outpcnumouts = len(inpactor.findall('port/[@type="out"]'))
        outpcname = ''
        if outpcnuminps > 0 and outpcnumouts > 0:
            # outpcname = 'kernel{}{}'.format(outpcnuminps, outpcnumouts)
            outpcname = 'kernelMN'

        elif outpcnuminps > 0 and outpcnumouts == 0:
            outpcname = 'source'
        else:
            outpcname = 'sink'
        outpc.set('name', outpcname)
        outpc.set('moc', 'sadf')
        if outpcname == 'kernelMN':
            ET.SubElement(outpc, 'argument', {'name': '_func', 'value': '{}_func'.format(actor_attribs['name'])})
            scenario_table = extract_scenario_table(actor_attribs['name'], inproot.find('applicationGraph'))
            ET.SubElement(outpc, 'argument', {'name': 'scenario_table', 'value': repr(scenario_table)})
    return outroot


def main():
    if len(sys.argv) != 3:
        print(__doc__)
        sys.exit(1)

    input_file_path = sys.argv[1]
    output_file_path = sys.argv[2]

    if not os.path.isfile(input_file_path):
        print('Input file does not exist.')
        sys.exit(1)

    if os.path.isfile(output_file_path):
        print('Output file already exists.')
        # sys.exit(1)

    tree = ET.parse(input_file_path)
    inproot = tree.getroot()
    outroot = sdf3_to_forsyde(inproot)

    # Generate the output XML
    xmlstr = minidom.parseString(ET.tostring(outroot)).toprettyxml(indent="   ")
    with open(output_file_path, "w") as f:
        f.write(xmlstr)

if __name__ == "__main__":
    main()