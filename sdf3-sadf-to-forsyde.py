#!/usr/bin/env python
'''\
This script converts an FSM-SADF model generated by the SDF3 tool to an SADF ForSyDe model.
The script takes as input the path to the SADF model and the path to the output file.

Usage: sdf3-sadf-to-forsyde.py <input_file_path> <output_file_path>
'''

import sys
import os
import xml.etree.ElementTree as ET
import xml.dom.minidom as minidom

'''\
Extract the scenario table from the generated SADF model.
The functions gets the actor name and the applicationGraph XML element as input and returns
the scenario table as a dictionary with the scenario as they key and a tuple of lists of
input and output consumption rates as the value. 
'''
def extract_scenario_table(actor_name, inproot):
    scenarios = inproot.find('fsmsadfProperties/scenarios')
    actor_graph = inproot.find('fsmsadf/scenariograph/actor/[@name="{}"]'.format(actor_name))
    scenario_table = {}
    for scenario in scenarios.findall('scenario'):
        scenario_table[scenario.attrib['name']] = ([], [])
        for inpport in scenario.findall('actorProperties/[@actor="{}"]/port'.format(actor_name)):
            if actor_graph.find('port/[@name="{}"]/[@type="in"]'.format(inpport.attrib['name'])) is not None:
                scenario_table[scenario.attrib['name']][0].append(int(inpport.attrib['rate']))
            else:
                scenario_table[scenario.attrib['name']][1].append(int(inpport.attrib['rate']))
    return scenario_table

'''\
Convert the SDF3-based SADF model to a ForSyDe-based SADF model.
The function gets the root XML element of the SDF3-generated FSM-SADF model and the repeatition vector as inputs and
returns the root XML element of the ForSyDe-based SADF model.
'''
def sdf3_to_forsyde(inproot, rv):
    inproot_sadf = inproot.find('applicationGraph/fsmsadf/scenariograph')

    # # Create the XML document
    # doc = minidom.Document()
    # Make a dictionary of token sizes for each channel
    token_sizes = {}
    for inpchannel in inproot_sadf.findall('channel'):
        # Extract all the token size nodes from all scenarios for a channel
        channel_attribs = inpchannel.attrib
        tokens = inproot.findall('applicationGraph/fsmsadfProperties/scenarios/scenario/channelProperties/[@channel="{}"]/tokenSize'.format(channel_attribs['name']))
        # Extract the maximum token size
        token_size = max([int(token_size.attrib['sz']) for token_size in tokens])
        token_sizes[channel_attribs['name']] = token_size

    # Create the root element
    outroot = ET.Element('process_network')
    outroot.set('name', os.path.splitext(os.path.basename(sys.argv[2]))[0])

    # Generate signals
    for inpchannel in inproot_sadf.findall('channel'):
        channel_attribs = inpchannel.attrib
        outsignal = ET.SubElement(outroot, 'signal')
        outsignal.set('name', channel_attribs['name'])
        outsignal.set('moc', 'sadf')
        outsignal.set('type', 'array<int,{}>'.format(token_sizes[channel_attribs['name']]))
        outsignal.set('source', channel_attribs['srcActor'])
        outsignal.set('source_port', channel_attribs['srcPort'])
        outsignal.set('target', channel_attribs['dstActor'])
        outsignal.set('target_port', channel_attribs['dstPort'])
    
    # Generate extra signals for connecting to the detector
    for idx,inpactor in enumerate(inproot_sadf.findall('actor')):
        actor_attribs = inpactor.attrib
        outsignal = ET.SubElement(outroot, 'signal')
        outsignal.set('name', actor_attribs['name'] + '_detectorsig')
        outsignal.set('moc', 'sadf')
        outsignal.set('type', 'unsigned int')
        outsignal.set('source', 'detector1')
        outsignal.set('source_port', 'oport{}'.format(idx+1))
        outsignal.set('target', actor_attribs['name'])
        outsignal.set('target_port', 'cport1')
    
    # Generate delay actors
    for inpchannel in inproot_sadf.findall('channel'):
        channel_attribs = inpchannel.attrib
        if 'initialTokens' in channel_attribs and int(channel_attribs['initialTokens']) > 0:
            # make a delayn
            outprocess = ET.SubElement(outroot, 'leaf_process')
            outprocess.set('name', channel_attribs['name'] + '_delay')
            ET.SubElement(outprocess, 'port', {'name': "iport1", 'moc': "sadf", 'type': "array<int,{}>".format(token_sizes[channel_attribs['name']]), 'direction': "in"})
            ET.SubElement(outprocess, 'port', {'name': "oport1", 'moc': "sadf", 'type': "array<int,{}>".format(token_sizes[channel_attribs['name']]), 'direction': "out"})
            outpc = ET.SubElement(outprocess, 'process_constructor', {'name': "delayn", 'moc': "sadf"})
            ET.SubElement(outpc, 'argument', {'name': "init_val", 'value': "array<int,{}>()".format(token_sizes[channel_attribs['name']])})
            ET.SubElement(outpc, 'argument', {'name': "n", 'value': channel_attribs['initialTokens']})

            # make a new signal
            outsignal = outroot.find("signal/[@name='{}']".format(channel_attribs['name']))
            newoutsig = ET.Element('signal')
            newoutsig.set('name', channel_attribs['name'] + '_delaysig')
            newoutsig.set('moc', 'sadf')
            newoutsig.set('type', "array<int,{}>".format(token_sizes[channel_attribs['name']]))
            newoutsig.set('source', channel_attribs['name'] + '_delay')
            newoutsig.set('source_port', 'oport1')
            newoutsig.set('target', outsignal.attrib['target'])
            newoutsig.set('target_port', outsignal.attrib['target_port'])
            outroot.insert(list(outroot).index(outroot.find('leaf_process')), newoutsig)

            # rewire the original signal
            outsignal.set('target', channel_attribs['name'] + '_delay')
            outsignal.set('target_port', 'iport1')
    
    # Generate the kernel processes
    for inpactor in inproot_sadf.findall('actor'):
        actor_attribs = inpactor.attrib
        outprocess = ET.SubElement(outroot, 'leaf_process')
        outprocess.set('name', actor_attribs['name'])
        # generate the control port from the detector
        ET.SubElement(outprocess, 'port', {'name': 'cport1', 'moc': 'sadf', 'type': 'unsigned int', 'direction': 'in'})
        # Generate the input and output ports
        for inpport in inpactor.findall('port'):
            port_attribs = inpport.attrib
            bound_channel = inproot_sadf.findall("channel/[@srcActor='{0}']/[@srcPort='{1}']".format(actor_attribs['name'], port_attribs['name'])) or inproot_sadf.findall("channel/[@dstActor='{0}']/[@dstPort='{1}']".format(actor_attribs['name'], port_attribs['name']))
            ET.SubElement(outprocess, 'port', {'name': port_attribs['name'], 'moc': 'sadf', 'type': "array<int,{}>".format(token_sizes[bound_channel[0].attrib['name']]), 'direction': port_attribs['type']})
        # Generate the process constructor
        outpc = ET.SubElement(outprocess, 'process_constructor')
        outpcnuminps = len(inpactor.findall('port/[@type="in"]'))
        outpcnumouts = len(inpactor.findall('port/[@type="out"]'))
        outpcname = ''
        if outpcnuminps > 0 and outpcnumouts > 0:
            # outpcname = 'kernel{}{}'.format(outpcnuminps, outpcnumouts)
            outpcname = 'kernelMN'

        elif outpcnuminps > 0 and outpcnumouts == 0:
            outpcname = 'source'
        else:
            outpcname = 'sink'
        outpc.set('name', outpcname)
        outpc.set('moc', 'sadf')
        if outpcname == 'kernelMN':
            ET.SubElement(outpc, 'argument', {'name': '_func', 'value': '{}_func'.format(actor_attribs['name'])})
            scenario_table = extract_scenario_table(actor_attribs['name'], inproot.find('applicationGraph'))
            scenario_table_fsd = [(idx,val) for idx,val in enumerate(scenario_table.values())]
            ET.SubElement(outpc, 'argument', {'name': 'scenario_table', 'value': repr(scenario_table_fsd)})
    
    # Generate the detector process
    outprocess = ET.SubElement(outroot, 'leaf_process')
    outprocess.set('name', 'detector1')
    for idx,kernel in enumerate(inproot_sadf.findall('actor')):
        ET.SubElement(outprocess, 'port', {'name': 'oport{}'.format(idx+1), 'moc': 'sadf', 'type': 'unsigned int', 'direction': 'out'})
    #ET.SubElement(outprocess, 'port', {'name': 'oport1', 'moc': 'sadf', 'type': 'unsigned int', 'direction': 'out'})
    outpc = ET.SubElement(outprocess, 'process_constructor', {'name': 'detectorMN', 'moc': 'sadf'})
    ET.SubElement(outpc, 'argument', {'name': 'cds_func', 'value': 'detectorcds_func'})
    ET.SubElement(outpc, 'argument', {'name': 'kss_func', 'value': 'detectorkss_func'})
    scenario_table_str = '[' + ','.join(['({},{})'.format(idx,list(rv.values())[idx]) for idx,val in enumerate(inproot.findall('applicationGraph/fsm/state'))]) + ']'
    ET.SubElement(outpc, 'argument', {'name': 'scenario_table', 'value': scenario_table_str})
    ET.SubElement(outpc, 'argument', {'name': 'init_sc', 'value': '0'})
    ET.SubElement(outpc, 'argument', {'name': 'itok', 'value': '{}'})

    return outroot

'''\
Read the repeatition vectors from the file.
The function gets the path to the repeatition vector file as input and returns a dictionary of scenarios to repeatition vectors.
The format of the output file is:
[s, 0]: [2, 1, 2, 1, 1]
[s, 1]: [2, 1, 2, 1, 1]
[s, 2]: [1, 1, 2, 1, 1]
...
'''
def extract_repeatition_vectors(rv_file_path):
    # Create the dictionary of scenarios to repeatition vectors
    scenarios_to_repeatitions = {}
    # Open the output file
    with open(rv_file_path, 'r') as f:
        # Iterate over the lines of the output file
        for line in f:
            # Extract the scenario name and the repeatition vector
            scenario_name, repeatition_vector = line.strip().split(':')
            scenario_name = scenario_name.strip()[1:-1]
            repeatition_vector = repeatition_vector.strip()#[1:-1]
            # Add the scenario to the dictionary
            scenarios_to_repeatitions[scenario_name] = repeatition_vector
            # scenarios_to_repeatitions[scenario_name] = [int(value.strip()) for value in repeatition_vector.split(',')]
    return scenarios_to_repeatitions

def main():
    if len(sys.argv) != 4:
        print(__doc__)
        sys.exit(1)

    input_file_path  = sys.argv[1]
    rv_file_path     = sys.argv[2]
    output_file_path = sys.argv[3]

    if not os.path.isfile(input_file_path):
        print('Input file does not exist.')
        sys.exit(1)
    
    if not os.path.isfile(rv_file_path):
        print('Repeatition vector file does not exist.')
        sys.exit(1)

    if os.path.isfile(output_file_path):
        print('Output file already exists.')
        # sys.exit(1)

    # Parse the input XML
    tree = ET.parse(input_file_path)
    inproot = tree.getroot()

    # Parse the repeatition vector file
    scenarios_to_repeatitions = extract_repeatition_vectors(rv_file_path)

    # Convert the SDF3-based SADF model to a ForSyDe-based SADF model
    outroot = sdf3_to_forsyde(inproot, scenarios_to_repeatitions)

    # Generate the output XML
    xmlstr = minidom.parseString(ET.tostring(outroot)).toprettyxml(indent="   ")
    with open(output_file_path, "w") as f:
        f.write(xmlstr)

if __name__ == "__main__":
    main()
