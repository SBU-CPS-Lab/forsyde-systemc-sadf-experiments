#!/usr/bin/env python
'''\
This script converts an FSM-SADF model generated by the SDF3 tool to an SADF ForSyDe model.
The script takes as input the path to the SADF model and the path to the output file.

Usage: sdf3-sadf-to-forsyde.py <input_file_path> <output_file_path>
'''

import sys
import os
import xml.etree.ElementTree as ET
import xml.dom.minidom as minidom

'''\
Extract the scenario table from the generated SADF model.
The functions gets the actor name and the applicationGraph XML element as input and returns
the scenario table as a dictionary with the scenario as they key and a tuple of lists of
input and output consumption rates as the value. 
'''
def extract_scenario_table(actor_name, inproot):
    scenarios = inproot.find('fsmsadfProperties/scenarios')
    actor_graph = inproot.find('fsmsadf/scenariograph/actor/[@name="{}"]'.format(actor_name))
    scenario_table = {}
    for scenario in scenarios.findall('scenario'):
        scenario_table[scenario.attrib['name']] = ([], [])
        for inpport in scenario.findall('actorProperties/[@actor="{}"]/port'.format(actor_name)):
            if actor_graph.find('port/[@name="{}"]/[@type="in"]'.format(inpport.attrib['name'])) is not None:
                scenario_table[scenario.attrib['name']][0].append(int(inpport.attrib['rate']))
            else:
                scenario_table[scenario.attrib['name']][1].append(int(inpport.attrib['rate']))
    return scenario_table

'''\
Convert the SDF3-based SADF model to a ForSyDe-based SADF model.
The function gets the root XML element of the SDF3-generated FSM-SADF model as input and
returns the root XML element of the ForSyDe-based SADF model.
'''
def sdf3_to_forsyde(inproot):
    inproot_sadf = inproot.find('applicationGraph/fsmsadf/scenariograph')

    # # Create the XML document
    # doc = minidom.Document()

    # Create the root element
    outroot = ET.Element('process_network')
    outroot.set('name', os.path.splitext(os.path.basename(sys.argv[2]))[0])

    # Generate signals
    for inpchannel in inproot_sadf.findall('channel'):
        channel_attribs = inpchannel.attrib
        outsignal = ET.SubElement(outroot, 'signal')
        outsignal.set('name', channel_attribs['name'])
        outsignal.set('moc', 'sadf')
        outsignal.set('type', 'double')
        outsignal.set('source', channel_attribs['srcActor'])
        outsignal.set('source_port', channel_attribs['srcPort'])
        outsignal.set('target', channel_attribs['dstActor'])
        outsignal.set('target_port', channel_attribs['dstPort'])
    
    # Generate extra signals for connecting to the detector
    for idx,inpactor in enumerate(inproot_sadf.findall('actor')):
        actor_attribs = inpactor.attrib
        outsignal = ET.SubElement(outroot, 'signal')
        outsignal.set('name', actor_attribs['name'] + '_detectorsig')
        outsignal.set('moc', 'sadf')
        outsignal.set('type', 'unsigned int')
        outsignal.set('source', 'detector1')
        outsignal.set('source_port', 'oport{}'.format(idx+1))
        outsignal.set('target', actor_attribs['name'])
        outsignal.set('target_port', 'cport1')
    
    # Generate delay actors
    for inpchannel in inproot_sadf.findall('channel'):
        channel_attribs = inpchannel.attrib
        if 'initialTokens' in channel_attribs and channel_attribs['initialTokens'] > '0':
            # make a delayn
            outprocess = ET.SubElement(outroot, 'leaf_process')
            outprocess.set('name', channel_attribs['name'] + '_delay')
            ET.SubElement(outprocess, 'port', {'name': "iport1", 'moc': "sadf", 'type': "double", 'direction': "in"})
            ET.SubElement(outprocess, 'port', {'name': "oport1", 'moc': "sadf", 'type': "double", 'direction': "out"})
            outpc = ET.SubElement(outprocess, 'process_constructor', {'name': "delayn", 'moc': "sadf"})
            ET.SubElement(outpc, 'argument', {'name': "init_val", 'value': "0.0"})
            ET.SubElement(outpc, 'argument', {'name': "n", 'value': channel_attribs['initialTokens']})

            # make a new signal
            outsignal = outroot.find("signal/[@name='{}']".format(channel_attribs['name']))
            newoutsig = ET.Element('signal')
            newoutsig.set('name', channel_attribs['name'] + '_delaysig')
            newoutsig.set('moc', 'sadf')
            newoutsig.set('type', 'double')
            newoutsig.set('source', channel_attribs['name'] + '_delay')
            newoutsig.set('source_port', 'oport1')
            newoutsig.set('target', outsignal.attrib['target'])
            newoutsig.set('target_port', outsignal.attrib['target_port'])
            outroot.insert(list(outroot).index(outroot.find('leaf_process')), newoutsig)

            # rewire the original signal
            outsignal.set('target', channel_attribs['name'] + '_delay')
            outsignal.set('target_port', 'iport1')
    
    # Generate the kernel processes
    for inpactor in inproot_sadf.findall('actor'):
        actor_attribs = inpactor.attrib
        outprocess = ET.SubElement(outroot, 'leaf_process')
        outprocess.set('name', actor_attribs['name'])
        # generate the control port from the detector
        ET.SubElement(outprocess, 'port', {'name': 'cport1', 'moc': 'sadf', 'type': 'unsigned int', 'direction': 'in'})
        # Generate the input and output ports
        for inpport in inpactor.findall('port'):
            port_attribs = inpport.attrib
            ET.SubElement(outprocess, 'port', {'name': port_attribs['name'], 'moc': 'sadf', 'type': 'double', 'direction': port_attribs['type']})
        # Generate the process constructor
        outpc = ET.SubElement(outprocess, 'process_constructor')
        outpcnuminps = len(inpactor.findall('port/[@type="in"]'))
        outpcnumouts = len(inpactor.findall('port/[@type="out"]'))
        outpcname = ''
        if outpcnuminps > 0 and outpcnumouts > 0:
            # outpcname = 'kernel{}{}'.format(outpcnuminps, outpcnumouts)
            outpcname = 'kernelMN'

        elif outpcnuminps > 0 and outpcnumouts == 0:
            outpcname = 'source'
        else:
            outpcname = 'sink'
        outpc.set('name', outpcname)
        outpc.set('moc', 'sadf')
        if outpcname == 'kernelMN':
            ET.SubElement(outpc, 'argument', {'name': '_func', 'value': '{}_func'.format(actor_attribs['name'])})
            scenario_table = extract_scenario_table(actor_attribs['name'], inproot.find('applicationGraph'))
            scenario_table_fsd = [(idx,val) for idx,val in enumerate(scenario_table.values())]
            ET.SubElement(outpc, 'argument', {'name': 'scenario_table', 'value': repr(scenario_table_fsd)})
    
    # Generate the detector process
    outprocess = ET.SubElement(outroot, 'leaf_process')
    outprocess.set('name', 'detector1')
    for idx,kernel in enumerate(inproot_sadf.findall('actor')):
        ET.SubElement(outprocess, 'port', {'name': 'oport{}'.format(idx+1), 'moc': 'sadf', 'type': 'unsigned int', 'direction': 'out'})
    #ET.SubElement(outprocess, 'port', {'name': 'oport1', 'moc': 'sadf', 'type': 'unsigned int', 'direction': 'out'})
    outpc = ET.SubElement(outprocess, 'process_constructor', {'name': 'detectorMN', 'moc': 'sadf'})
    ET.SubElement(outpc, 'argument', {'name': 'cds_func', 'value': 'detectorcds_func'})
    ET.SubElement(outpc, 'argument', {'name': 'kss_func', 'value': 'detectorkss_func'})
    #  make a string of the form '[1,1,...,1]' where the number of 1's is the number of kernels
    out_prod_str = '[' + ','.join(['1' for val in inproot_sadf.findall('actor')]) + ']'
    scenario_table_str = '[' + ','.join(['({},{})'.format(idx,out_prod_str) for idx,val in enumerate(inproot.findall('applicationGraph/fsm/state'))]) + ']'
    ET.SubElement(outpc, 'argument', {'name': 'scenario_table', 'value': scenario_table_str})
    ET.SubElement(outpc, 'argument', {'name': 'init_sc', 'value': '0'})
    ET.SubElement(outpc, 'argument', {'name': 'itok', 'value': '{}'})

    return outroot


def main():
    if len(sys.argv) != 3:
        print(__doc__)
        sys.exit(1)

    input_file_path = sys.argv[1]
    output_file_path = sys.argv[2]

    if not os.path.isfile(input_file_path):
        print('Input file does not exist.')
        sys.exit(1)

    if os.path.isfile(output_file_path):
        print('Output file already exists.')
        # sys.exit(1)

    tree = ET.parse(input_file_path)
    inproot = tree.getroot()
    outroot = sdf3_to_forsyde(inproot)

    # Generate the output XML
    xmlstr = minidom.parseString(ET.tostring(outroot)).toprettyxml(indent="   ")
    with open(output_file_path, "w") as f:
        f.write(xmlstr)

if __name__ == "__main__":
    main()